{
  "magic": "E!vIA5L86J2I",
  "timestamp": "2024-11-26T00:22:07.641160+00:00",
  "repo": "kazuho/draft-kazuho-httpbis-incremental-http",
  "labels": [
    {
      "name": "bug",
      "description": "Something isn't working",
      "color": "d73a4a"
    },
    {
      "name": "documentation",
      "description": "Improvements or additions to documentation",
      "color": "0075ca"
    },
    {
      "name": "duplicate",
      "description": "This issue or pull request already exists",
      "color": "cfd3d7"
    },
    {
      "name": "enhancement",
      "description": "New feature or request",
      "color": "a2eeef"
    },
    {
      "name": "good first issue",
      "description": "Good for newcomers",
      "color": "7057ff"
    },
    {
      "name": "help wanted",
      "description": "Extra attention is needed",
      "color": "008672"
    },
    {
      "name": "invalid",
      "description": "This doesn't seem right",
      "color": "e4e669"
    },
    {
      "name": "question",
      "description": "Further information is requested",
      "color": "d876e3"
    },
    {
      "name": "wontfix",
      "description": "This will not be worked on",
      "color": "ffffff"
    }
  ],
  "issues": [
    {
      "number": 1,
      "id": "I_kwDOMZBL0M6Qmq8z",
      "title": "Structured Fields",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/1",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "This changes this to `?1` from `1`.  It might make things neater.",
      "createdAt": "2024-07-23T20:19:55Z",
      "updatedAt": "2024-07-29T02:43:38Z",
      "closedAt": "2024-07-29T02:43:38Z",
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "I agree that we should be using Structured Fields in new I-Ds, even when the header value is not used in any particular way.",
          "createdAt": "2024-07-26T01:42:06Z",
          "updatedAt": "2024-07-26T01:42:06Z"
        }
      ]
    },
    {
      "number": 2,
      "id": "I_kwDOMZBL0M6Qmt3p",
      "title": "Field name ... or maybe just semantics too",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/2",
      "state": "CLOSED",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "A name of \"request-streaming\" implies that this only applies to requests.  That's not really necessary.  I think that it would be helpful to have this be more general.  This can be a per-message basis.\r\n\r\nI would suggest \"Stream-Body\" or \"Incr[emental]-Delivery\" or even just \"Incremental\".  This is a signal from the sender of that message to any intermediary that incremental delivery of this message would be optimal.  Importantly, a request can't speak about a response.",
      "createdAt": "2024-07-23T20:26:44Z",
      "updatedAt": "2024-10-15T00:19:40Z",
      "closedAt": "2024-10-15T00:19:40Z",
      "comments": [
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "Or \"Incr[emental]-Forwarding\" or \"Forward-Incr\" so that it is about *forwarding* expectations.",
          "createdAt": "2024-07-23T20:28:26Z",
          "updatedAt": "2024-07-23T20:28:26Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "Thank you for starting the discussion.\r\n\r\n> A name of \"request-streaming\" implies that this only applies to requests. \r\n\r\nThis I agree with. To fix the issue, I think it might be a good idea to include the term \"bidirectional,\" due to the following reasons:\r\n* I think people think that HTTP response is streamed (because browsers render incrementally!).\r\n* The only case that we have this problem is when applications want streaming in both directions - blocking intermediaries work perfectly fine if only the request (or the response) is streamed.\r\n\r\nSeparately, I think we'd prefer having a name that adequately acquires the attention of HTTP application developers when they:\r\n* try to create applications that do bi-directional streaming, or\r\n* when they hit issues by doing that.\r\n\r\nDue to the first bullet point, I'm somewhat negative to having something like \"Forwarding\" in the title, even though such title might be technically correct.\r\n\r\nI think we want the streaming header to be set by any application that needs bi-directional streaming, regardless of intermediaries being involved in their deployments. That is because we do not want to see those applications break when they add buffering intermediaries.\r\n\r\nTo paraphrase, setting the streaming header always would be the way to adhere to the HTTP semantics for those applications.\r\n\r\nSo, I think my preference goes to something like \"Bidirectional Streaming of HTTP Bodies\". WDYT?",
          "createdAt": "2024-07-26T02:55:18Z",
          "updatedAt": "2024-07-26T02:55:18Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "So I don't think that bidirectional is the important property.  After all, if the request is buffered and the response is not, you don't have full duplex (or bidirectional) communication.  That is something you might get with [server sent events](https://html.spec.whatwg.org/multipage/server-sent-events.html), which this would make far more reliable overall (if intermediaries supported the signaling, that is, independent of any preexisting arrangements that have been setup, which I know is common for existing uses of SSE).\r\n\r\nThe key property is that data is forwarded as it arrives at an intermediary, not buffered.  `Unbuffered` might be a negative framing of this that works (even if I don't ordinarily like using negative names).\r\n\r\nThe fact that two unbuffered messages can be assembled to form voltron^wa bidirectional protocol is interesting, but not an essential property.\r\n\r\nI also don't think that you can assume that an unbuffered request naturally leads to an unbuffered response.  It could in a great many cases (100-continue is a good example of that, especially with OHTTP).  But not all.  Incremental processing is often valuable for large bodies, such that buffering is a performance hazard.\r\n\r\nSo, for me at least, bidirectional communication should feature prominently in the rationale, but it should not be how the feature is defined.  It should just be a consequence of one of the ways that the feature is used.",
          "createdAt": "2024-07-31T03:02:33Z",
          "updatedAt": "2024-07-31T03:02:33Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "FWIW my point has been that a client or a server cannot tell if an intermediary is buffering in either direction, unless they try to use HTTP request-response as a bi-directional channel.\r\n\r\nBut I can see some might argue otherwise if they take out-of-band knowledge into consideration.\r\n\r\nTo that end, I do not have a strong reason to object against the idea of changing the header field to indicate how the HTTP message is delivered in each direction.",
          "createdAt": "2024-07-31T05:18:38Z",
          "updatedAt": "2024-07-31T05:18:38Z"
        },
        {
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "body": "Thanks @kazuho.  The only question I have then is whether it is useful for the client to be able to signal as part of a request whether it wants the response to be streamed.\r\n\r\nI suspect that the answer there is that the server will know that a response should be streamed and mark the response properly.  I'm trying to think of cases where that wouldn't be true and not finding any.",
          "createdAt": "2024-08-05T01:26:43Z",
          "updatedAt": "2024-08-05T01:26:43Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "@martinthomson \r\n> The only question I have then is whether it is useful for the client to be able to signal as part of a request whether it wants the response to be streamed.\r\n> \r\n> I suspect that the answer there is that the server will know that a response should be streamed and mark the response properly. I'm trying to think of cases where that wouldn't be true and not finding any.\r\n\r\n+1 to _not_ giving client also control. \r\n\r\nFWIW, in case of newly written applications, server developers would have the opportunity to set the flag. In contrast, having such a feature would be helpful to existing applications that need bi-directional streaming, as one would need to change only one side.\r\n\r\nSome people might argue (or presume) that such a flag would be useful for clients that can process the response incrementally. Consider a MP3 player. It would always be helpful for them to receive response incrementally, as the playback can start earlier.\r\n\r\nBut the fact is that we do not want to start such a arms race, where everybody starts setting the flag, as then, proxies become unable to respect the flag.\r\n\r\nTo conclude, I think we should be clear that the flag is specifically for protocols that break if the intermediaries buffer the HTTP message. That flag changes the policy of intermediaries from \"forward-now-or-buffer\" to  \"forward-now-or-fail\" (though I'm not sure how intermediaries can fail if they see the flag attached to the response).",
          "createdAt": "2024-08-05T23:15:46Z",
          "updatedAt": "2024-08-05T23:15:46Z"
        },
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "@martinthomson Sorry for not making progress. I've filed #4, PTAL.",
          "createdAt": "2024-10-14T14:18:43Z",
          "updatedAt": "2024-10-14T14:18:43Z"
        }
      ]
    },
    {
      "number": 7,
      "id": "I_kwDOMZBL0M6bSMOR",
      "title": "Allow for `Incremental: ?0`",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/7",
      "state": "OPEN",
      "author": "thibmeu",
      "authorAssociation": "NONE",
      "assignees": [],
      "labels": [],
      "body": "In its current state, the draft only allows one value: `?1`. This means there are two states:\r\n* No header, and the server uses its default\r\n* `Incremental: ?1` and the server allows incremental request/response\r\n\r\nI think the state `Incremental: ?0` should be mentioned, and allowed. For instance, OHTTP has privacy concerns with incremental/chunked response. These concerns go away when the request and responses are buffered. Client should be able to inform the server they would like to use this mode.\r\n\r\nSimilar to `Incremental: ?1`, the server could perfectly ignore this header, or return they don't support it.",
      "createdAt": "2024-10-22T11:55:16Z",
      "updatedAt": "2024-11-03T12:21:47Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "Thank you for raising the point.\r\n\r\nI do not understand the security aspects of OHTTP and I could be wrong, but could you clarify why it is preferable to have a network signal rather than relying on local decision (i.e., server itself can wait for the entire request, then send the entire response at once)?",
          "createdAt": "2024-11-01T20:59:56Z",
          "updatedAt": "2024-11-01T20:59:56Z"
        },
        {
          "author": "thibmeu",
          "authorAssociation": "NONE",
          "body": "Incremental being broader than OHTTP, there could be other use cases that require buffering down the line.\r\n\r\nFor your question on OHTTP specifically, my understanding is as follow:\r\n\r\nOHTTP [initial figure](https://www.rfc-editor.org/rfc/rfc9458#section-2-4.1.1) highlights the relay sends the request to the gateway, and waits for its response before replying to the client.\r\n[RFC 9458 Section 6.2.3](https://www.rfc-editor.org/rfc/rfc9458#name-traffic-analysis) discusses how an attacker can do traffic analysis. One mitigation is for Relay to add delay.\r\n\r\nFor chunked OHTTP, this would also include buffering client request/gateway response. By buffering the entire request before sending the entire response, the relay prevents an attacker from being able to fingerprint a client by granularily sending packets (time, size, others).\r\nThis interactivity privacy consideration is highlighted in the [draft for chunked OHTTP](\r\nhttps://datatracker.ietf.org/doc/html/draft-ietf-ohai-chunked-ohttp-02#name-interactivity-and-privacy).\r\n",
          "createdAt": "2024-11-03T12:21:45Z",
          "updatedAt": "2024-11-03T12:21:45Z"
        }
      ]
    },
    {
      "number": 8,
      "id": "I_kwDOMZBL0M6cwEvr",
      "title": "add signal for requesting incremental delivery but with fallback to buffered, rather than rejection",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/8",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the draft states that intermediaries can reject HTTP requests when incremental delivery is impossible. This works well for applications that rely on incremental delivery, because receiving an error is better than intermediaries silently buffering the HTTP messages.\r\n\r\nBut some applications want incremental delivery as an optimization. A borderline example is Resumable Uploads, [as pointed out by Marius on the mailing list](https://lists.w3.org/Archives/Public/ietf-http-wg/2024OctDec/0046.html). Resumable Uploads is unlikely to provide benefit when an intermediary buffers the entire request before forwarding it to upstream, because no data will reach upstream when the client connection is disrupted. But upload succeeds unless the connection is disrupted, and in that sense, incremental delivery is an optimization.\r\n\r\nTo paraphrase, for the use cases like Resumable Uploads, it might make sense to have a signal indicating \"please deliver incrementally, but otherwise buffer rather than rejecting.\"\r\n\r\nThe counterargument for having such kind of signal would be that, because almost all applications benefit from incremental delivery (the data arrives earlier!), it is always the desired behavior that all intermediaries should implement, and therefore that we do not want a signal for requesting that.",
      "createdAt": "2024-11-01T20:48:07Z",
      "updatedAt": "2024-11-01T20:50:31Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 9,
      "id": "I_kwDOMZBL0M6cwOZx",
      "title": "let intermediaries signal HTTP servers the intent to deliver incrementally",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/9",
      "state": "OPEN",
      "author": "kazuho",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "At the moment, the incremental signal is generated by the original sender of the HTTP message and is attached to each HTTP message, in both directions.\r\n\r\nIn the thread starting from https://lists.w3.org/Archives/Public/ietf-http-wg/2024OctDec/0054.html, @lpardue argues it could make sense to let intermediaries attach to HTTP _requests_ they forward an HTTP header indicating if the intermediary is willing (or refusing) to forward the _response_ incrementally.\r\n\r\nThe benefits of doing so are, quoting from https://lists.w3.org/Archives/Public/ietf-http-wg/2024OctDec/0058.html:\r\n> a) the proxy can't signal with much fidelity to the origin why it aborted the response prematurely. This could get aliased with other connectivity or operational issues.\r\n> b) the origin might have committed to doing work that it could have avoided. Not all jobs can be cancelled easily. An L7 load balancer could easily be setup with a blanket rule to reject requests that don't have the \"i can do the thing u need\" header, saving a more expensive call to a DB or 3rd party or whatever.\r\n> c) avoiding entirely unavoidable work is good. My understanding of the motivation was to avoid needing brittle config, and to embrace in-band signalling so it can be more adaptive. Taking some of the decision making responsibility out of the proxy might make this easier to deploy.",
      "createdAt": "2024-11-01T21:19:54Z",
      "updatedAt": "2024-11-01T21:19:54Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 10,
      "id": "I_kwDOMZBL0M6cx6W9",
      "title": "Buffering delays and interaction with incremental delivery",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/10",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Buffering can be about the time that the first byte is held waiting for the last byte or the time that the first byte is held waiting for $ENOUGH bytes to arrive.\r\n\r\nSome applications want incremental delivery of any amount of delay, so long as $t_{last}-t_{first}$ isn't effectively infinite.  Especially for intermediaries where time is not the factor they use in buffering.  That is, as noted, some intermediaries likely allocate a finite buffer and only forward once that buffer hits a predetermined threshold, which might not happen in the sorts of use cases we're talking about.\r\n\r\nConsider a pub-sub arrangement that uses SSE, which probably won't care if there is some amount of buffering or delay.\r\n\r\nSome applications want zero buffering.  These are the ones that are probably most likely to expose the system to problems like slowloris or other attacks.  These are probably not that common though.\r\n\r\nMost are probably looking for some finite, but reasonable, amount of buffering delay.  In a way, asking for incremental delivery is about bounding the buffering delay.\r\n\r\nIs there some amount of guidance we can give about this?  Is there any point in trying to indicate what sort of forwarding delay is a) desired and b) applied?",
      "createdAt": "2024-11-02T08:57:53Z",
      "updatedAt": "2024-11-02T12:26:51Z",
      "closedAt": null,
      "comments": [
        {
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "body": "> Some applications want zero buffering. These are the ones that are probably most likely to expose the system to problems like Slowloris or other attacks.\r\n\r\nI think we can go for zero buffering at best effort basis (like CONNECT).\r\n\r\nSlowloris is an attack against the concurrency limit. It does send data slowly, but that is to prevent requests inflight from getting closed due to timeouts.\r\n\r\nAs long as intermediaries can reduce the frequency of I/O operations when under load, I think the security risk imposed to the server would be manageable.",
          "createdAt": "2024-11-02T12:26:49Z",
          "updatedAt": "2024-11-02T12:26:49Z"
        }
      ]
    },
    {
      "number": 11,
      "id": "I_kwDOMZBL0M6c5v6K",
      "title": "Tri-state",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/11",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Ted Hardie suggested that we might have three states:\r\n\r\n1. Incremental is necessary\r\n2. Incremental is preferred, but not essential\r\n3. Incremental is not necessary\r\n\r\nThis seems like a better way than #7 and more general overall.\r\n\r\nI suggest a/p/n for always/preferred/not preferred.",
      "createdAt": "2024-11-04T10:12:05Z",
      "updatedAt": "2024-11-04T10:12:05Z",
      "closedAt": null,
      "comments": []
    },
    {
      "number": 12,
      "id": "I_kwDOMZBL0M6c50Uz",
      "title": "Requests indicating preferences about responses",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/issues/12",
      "state": "OPEN",
      "author": "martinthomson",
      "authorAssociation": "COLLABORATOR",
      "assignees": [],
      "labels": [],
      "body": "Discussion in the session highlighted that there is potentially value in having clients signal to servers that they might prefer an incrementally-delivered response.  We might frame that as `Prefer: incremental`, to complement the forward-direction `Incremental: ??` signal.",
      "createdAt": "2024-11-04T10:20:37Z",
      "updatedAt": "2024-11-04T10:20:37Z",
      "closedAt": null,
      "comments": []
    }
  ],
  "pulls": [
    {
      "number": 3,
      "id": "PR_kwDOMZBL0M52hyYe",
      "title": "switch to Structured Fields",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/pull/3",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As suggested by @martinthomson in #1.",
      "createdAt": "2024-07-26T01:40:44Z",
      "updatedAt": "2024-07-29T02:43:32Z",
      "baseRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "baseRefName": "main",
      "baseRefOid": "bf77dc3e7113abb85df5ac0e72311b622ee3aaee",
      "headRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "headRefName": "kazuho/structured-fields",
      "headRefOid": "0adb009ad757423e60c5a472aa363418f772c4eb",
      "closedAt": "2024-07-29T02:43:32Z",
      "mergedAt": "2024-07-29T02:43:32Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "af2ae1b20ffd8ed9db1f0d3f50da57efacc9ec31"
      },
      "comments": [],
      "reviews": []
    },
    {
      "number": 4,
      "id": "PR_kwDOMZBL0M5-jU58",
      "title": "change to unidirectional signal called \"Incremental\"",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/pull/4",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "As discussed in #2, the header field now applies to the HTTP message to which it is attached. Also, the name is changed to Incremental.\r\n\r\nCloses #2.",
      "createdAt": "2024-10-14T14:17:11Z",
      "updatedAt": "2024-10-15T00:19:39Z",
      "baseRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "baseRefName": "main",
      "baseRefOid": "af2ae1b20ffd8ed9db1f0d3f50da57efacc9ec31",
      "headRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "headRefName": "kazuho/unidirectional",
      "headRefOid": "8bb722b88bf2dc05d7a56b0355275ed616e8751a",
      "closedAt": "2024-10-15T00:19:39Z",
      "mergedAt": "2024-10-15T00:19:39Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "a92d951b55c20913a125f674bdb34022b459aa83"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMZBL0M6NGIvp",
          "commit": {
            "abbreviatedOid": "0ec5833"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-14T16:58:40Z",
          "updatedAt": "2024-10-14T16:59:37Z",
          "comments": [
            {
              "originalPosition": 87,
              "body": "Doesn't necessarily need to be bi-directional...\r\n```suggestion\r\ndisrupting the intended incremental processing of the request.\r\n```",
              "createdAt": "2024-10-14T16:58:40Z",
              "updatedAt": "2024-10-14T16:59:37Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nTo prevent such behavior, this document specifies the \"Incremental\" HTTP header\r\n```",
              "createdAt": "2024-10-14T16:58:53Z",
              "updatedAt": "2024-10-14T16:59:37Z"
            },
            {
              "originalPosition": 81,
              "body": "```suggestion\r\nresponse completely before forwarding it, the client might time out before\r\n```",
              "createdAt": "2024-10-14T16:59:03Z",
              "updatedAt": "2024-10-14T16:59:37Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMZBL0M6NIe3Z",
          "commit": {
            "abbreviatedOid": "b4e224b"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-14T23:25:50Z",
          "updatedAt": "2024-10-14T23:25:50Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMZBL0M6NIdHX",
          "commit": {
            "abbreviatedOid": "b4e224b"
          },
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-14T23:21:47Z",
          "updatedAt": "2024-10-14T23:28:51Z",
          "comments": [
            {
              "originalPosition": 56,
              "body": "```suggestion\r\nand incrementally sends application messages, while the server can start responding\r\n```",
              "createdAt": "2024-10-14T23:21:47Z",
              "updatedAt": "2024-10-14T23:28:51Z"
            },
            {
              "originalPosition": 89,
              "body": "```suggestion\r\nTo help avoid such behavior, this document specifies the \"Incremental\" HTTP header\r\n```",
              "createdAt": "2024-10-14T23:22:38Z",
              "updatedAt": "2024-10-14T23:28:51Z"
            },
            {
              "originalPosition": 144,
              "body": "```suggestion\r\nSuch intermediaries could apply a more restrictive concurrency limit to requests\r\n```",
              "createdAt": "2024-10-14T23:23:26Z",
              "updatedAt": "2024-10-14T23:28:51Z"
            },
            {
              "originalPosition": 132,
              "body": "```suggestion\r\n\r\nThe Incremental field is advisory. Intermediaries that are unaware of the field\r\nor that do not support the field might buffer messages, even when explicitly\r\nrequested otherwise.  Clients and servers therefore cannot expect all\r\nintermediaries to understand and respect a request to deliver messages\r\nincrementally. Clients can rely on prior knowledge or probe for support on\r\nindividual resources.\r\n```\r\n\r\n(Happy to take that to a separate change; it's not exactly simple.)",
              "createdAt": "2024-10-14T23:28:21Z",
              "updatedAt": "2024-10-14T23:28:51Z"
            }
          ]
        },
        {
          "id": "PRR_kwDOMZBL0M6NIuyM",
          "commit": {
            "abbreviatedOid": "c690700"
          },
          "author": "kazuho",
          "authorAssociation": "OWNER",
          "state": "COMMENTED",
          "body": "",
          "createdAt": "2024-10-15T00:18:27Z",
          "updatedAt": "2024-10-15T00:18:28Z",
          "comments": [
            {
              "originalPosition": 132,
              "body": "Let's get this in. As you say we might want to discuss, I think it is a fact that the signal is only advisory; it makes sense to point that out.",
              "createdAt": "2024-10-15T00:18:27Z",
              "updatedAt": "2024-10-15T00:18:28Z"
            }
          ]
        }
      ]
    },
    {
      "number": 5,
      "id": "PR_kwDOMZBL0M5-jeo4",
      "title": "add coauthors",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/pull/5",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "@tfpauly @martinthomson PTAL.",
      "createdAt": "2024-10-14T14:35:04Z",
      "updatedAt": "2024-10-15T00:19:50Z",
      "baseRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "baseRefName": "main",
      "baseRefOid": "bf3fd24f8e7df55059d0c9349ff318d0cb3d3db8",
      "headRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "headRefName": "kazuho/add-authors",
      "headRefOid": "90ea5941740fc707d25b2f01a610c4f6b8545446",
      "closedAt": "2024-10-15T00:19:50Z",
      "mergedAt": "2024-10-15T00:19:50Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "704a44a99f7ee5a32942de73d836feb9b50d5492"
      },
      "comments": [],
      "reviews": [
        {
          "id": "PRR_kwDOMZBL0M6NEydI",
          "commit": {
            "abbreviatedOid": "90ea594"
          },
          "author": "tfpauly",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-14T14:35:53Z",
          "updatedAt": "2024-10-14T14:35:53Z",
          "comments": []
        },
        {
          "id": "PRR_kwDOMZBL0M6NIc7o",
          "commit": {
            "abbreviatedOid": "90ea594"
          },
          "author": "martinthomson",
          "authorAssociation": "COLLABORATOR",
          "state": "APPROVED",
          "body": "",
          "createdAt": "2024-10-14T23:20:31Z",
          "updatedAt": "2024-10-14T23:20:31Z",
          "comments": []
        }
      ]
    },
    {
      "number": 6,
      "id": "PR_kwDOMZBL0M5-qjf2",
      "title": "rename files",
      "url": "https://github.com/kazuho/draft-kazuho-httpbis-incremental-http/pull/6",
      "state": "MERGED",
      "author": "kazuho",
      "authorAssociation": "OWNER",
      "assignees": [],
      "labels": [],
      "body": "Followup PR for #4.",
      "createdAt": "2024-10-15T11:55:31Z",
      "updatedAt": "2024-10-15T11:55:46Z",
      "baseRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "baseRefName": "main",
      "baseRefOid": "704a44a99f7ee5a32942de73d836feb9b50d5492",
      "headRepository": "kazuho/draft-kazuho-httpbis-incremental-http",
      "headRefName": "kazuho/rename-files",
      "headRefOid": "3d0de5c1710bcd19d4a7073c66e76bf49419b9d4",
      "closedAt": "2024-10-15T11:55:46Z",
      "mergedAt": "2024-10-15T11:55:46Z",
      "mergedBy": "kazuho",
      "mergeCommit": {
        "oid": "7b97ae2535774e422a992d1bba5760668c7e09d5"
      },
      "comments": [],
      "reviews": []
    }
  ]
}